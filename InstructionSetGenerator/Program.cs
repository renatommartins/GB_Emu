using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;

namespace InstructionSetGenerator
{
    class Program
    {
        delegate void InstructionParser(int index, string instruction, out string autoGeneratedCode);

        static List<string> opCodes = null;

        static bool isFetching = true;
        static HttpClient httpClient = new HttpClient();

        static bool isParsing = true;
        static Dictionary<string, InstructionParser> instructionParsers = new System.Collections.Generic.Dictionary<string, InstructionParser>
        {
            #region Loads
            {
                "LD",
                (int index, string instruction ,out string autoGeneratedCode) =>
                {
                    string[] parameters = instruction.Split(' ')[1].Split(',');

                    string disassembly = "";
                    int cycles = 0;
                    int operandLength = 0;
                    string instructionCode = "";

                    autoGeneratedCode =
                    $"\t\t\t//{instruction}\n" +
                    $"\t\t\t{{\n" +
                    $"\t\t\t\t0x{index.ToString("X2")},\n" +
                    $"\t\t\t\tnew Instruction()\n" +
                    $"\t\t\t\t{{\n" +
                    $"\t\t\t\t\tdisassembly = {disassembly}\n" +
                    $"\t\t\t\t\tcycles = {cycles}\n" +
                    $"\t\t\t\t\toperandLength = {operandLength}\n" +
                    $"\t\t\t\t\tmethod = (gameboy, operands) => " +
                    $"\t\t\t\t\t{{\n";
                    autoGeneratedCode += instructionCode;
                    autoGeneratedCode +=
                    $"\t\t\t\t\t}}\n" +
                    $"\t\t\t\t}}\n" +
                    $"\t\t\t}},\n";
                }
            },
            {
                "LDD",
                null
            },
            {
                "LDI",
                null
            },
            {
                "LDH",
                null
            },
            {
                "LDHL",
                null
            },
            {
                "PUSH",
                null
            },
            {
                "POP",
                null
            },
            #endregion

            #region Arithmetic
            {
                "ADD",
                null
            },
            {
                "ADC",
                null
            },
            {
                "SUB",
                null
            },
            {
                "SBC",
                null
            },
            {
                "AND",
                null
            },
            {
                "OR",
                null
            },
            {
                "XOR",
                null
            },
            {
                "CP",
                null
            },
            {
                "INC",
                null
            },
            {
                "DEC",
                null
            },
            #endregion

            #region Miscellaneous
            {
                "SWAP",
                null
            },
            {
                "DAA",
                null
            },
            {
                "CPL",
                null
            },
            {
                "CCF",
                null
            },
            {
                "SCF",
                null
            },
            {
                "NOP",
                null
            },
            {
                "HALT",
                null
            },
            {
                "STOP",
                null
            },
            {
                "DI",
                null
            },
            {
                "EI",
                null
            },
            #endregion

            #region Rotates and Shifts
            {
                "RLCA",
                null
            },
            {
                "RLA",
                null
            },
            {
                "RRCA",
                null
            },
            {
                "RRA",
                null
            },
            {
                "RLC",
                null
            },
            {
                "RL",
                null
            },
            {
                "RRC",
                null
            },
            {
                "RR",
                null
            },
            {
                "SLA",
                null
            },
            {
                "SRA",
                null
            },
            {
                "SRL",
                null
            },
            #endregion

            #region Bit
            {
                "BIT",
                null
            },
            {
                "SET",
                null
            },
            {
                "RES",
                null
            },
            #endregion

            #region Jumps
            {
                "JP",
                null
            },
            {
                "JR",
                null
            },
            #endregion

            #region Calls
            {
                "CALL",
                null
            },
            #endregion

            #region Restarts
            {
                "RST",
                null
            },
            #endregion

            #region Returns
            {
                "RET",
                null
            },
            {
                "RETI",
                null
            },
            #endregion

            #region Removed
            {
                "XX",
                (int index, string instruction ,out string autoGeneratedCode) =>
                {
                    autoGeneratedCode =
                    $"\t\t\t//Removed\n" +
                    $"\t\t\t{{\n" +
                    $"\t\t\t\t0x{index.ToString("X2")},\n" +
                    $"\t\t\t\tnew Instruction()\n" +
                    $"\t\t\t\t{{\n" +
                    $"\t\t\t\t\tdisassembly = \"\"\n" +
                    $"\t\t\t\t\tcycles = 0\n" +
                    $"\t\t\t\t\toperandLength = 0\n" +
                    $"\t\t\t\t\tmethod = (gameboy, operands) => " +
                    $"\t\t\t\t\t{{\n" +
                    $"\t\t\t\t\t\tthrow new Exception(\"Instruction removed\");\n" +
                    $"\t\t\t\t\t}}\n" +
                    $"\t\t\t\t}}\n" +
                    $"\t\t\t}},\n";
                }
            },
            #endregion
        };

        static void Main(string[] args)
        {
            if(!File.Exists("E:\\opCodeDumpClean.txt"))
            {
                Fetching();

                while (isFetching)
                {
                    Thread.Sleep(1000);
                }
            }
            else
            {
                opCodes = new List<string>();
                StreamReader reader = new StreamReader(File.OpenRead("E:\\opCodeDumpClean.txt"));
                while(!reader.EndOfStream)
                {
                    opCodes.Add(reader.ReadLine());
                }
            }

            if(opCodes.Count > 0)
            {
                Parsing();
                while(isParsing)
                {
                    Thread.Sleep(1000);
                }
            }
        }

        static async void Fetching()
        {
            HttpResponseMessage message = await httpClient.GetAsync("http://imrannazar.com/Gameboy-Z80-Opcode-Map");
            MatchCollection matches = Regex.Matches(
                await message.Content.ReadAsStringAsync(),
                "<td><abbr title=[a-z,A-Z,\",', ,\\-,+,0-9,\\(,\\)]*>[A-Z,a-z,0-9, ,\\,,\\(,\\)]*<\\/abbr><\\/td>\n");

            List<string> opCodeList = matches.Cast<Match>().Select(match => match.Value).ToList();
            List<string> cleanOpCodeList = new List<string>();

            Console.WriteLine(opCodeList.Count);

            StreamWriter writer = File.CreateText("E:\\opCodeDumpDirty.txt");
            for(int i=0; i<opCodeList.Count; i++)
            {
                cleanOpCodeList.Add(Regex.Replace(opCodeList[i], "<td><abbr title=[a-z,A-Z,\", ', ,\\-,+,0-9,\\(,\\)]*>|<\\/abbr><\\/td>", ""));
                writer.Write(opCodeList[i]);
            }
            writer.Close();
            writer.Dispose();

            writer = File.CreateText("E:\\opCodeDumpClean.txt");
            for(int i=0; i<cleanOpCodeList.Count; i++)
            {
                writer.Write(cleanOpCodeList[i]);
            }
            writer.Close();
            writer.Dispose();

            opCodes = cleanOpCodeList;

            isFetching = false;
        }

        static async void Parsing()
        {
            System.Text.StringBuilder builder = new System.Text.StringBuilder();
            
            #region Base File Start
            builder.Append(
                "using System;\n" +
                "using System.Collections.Generic;\n" +
                "using System.Text;\n" +
                "\n" +
                "namespace GBBase\n" +
                "{\n" +
                "\tpublic partial class Interpreter\n" +
                "\t{\n" +
                "\t\tpublic delegate void InstructionMethod(GameboyHardware gameboy, params byte[] operands);\n" +
                "\n" +
                "\t\tpublic struct Instruction\n" +
                "\t\t{\n" +
                "\t\t\tpublic string disassembly;\n" +
                "\t\t\tpublic byte cycles;\n" +
                "\t\t\tpublic byte operandLength;\n" +
                "\t\t\tpublic InstructionMethod method;\n" +
                "\t\t}\n" +
                "\n" +
                "\t\tprivate static void AssertOperands(byte length, byte[] operands)\n" +
                "\t\t{\n" +
                "\t\t\tif(\n" +
                "\t\t\t\t(length > 0 && length > operands.Length) ||\n" +
                "\t\t\t\t(length == 0 && (operands != null || operands.Length > 0))\n" +
                "\t\t\t\t)\n" +
                "\t\t\t{\n" +
                "\t\t\t\tthrow new ArgumentException(\"invalid operands\");\n" +
                "\t\t\t}\n" +
                "\t\t}\n" +
                "\n" +
                "\t\tprivate static Dictionary<byte, Instruction> _instructionSet = new Dictionary<byte, Instruction>()\n" +
                "\t\t{\n");
            #endregion

            for (int i = 0; i < opCodes.Count && i <256; i++)
            {
                string opCodeKey = opCodes[i].Split(' ')[0];
                if (instructionParsers.ContainsKey(opCodeKey))
                {
                    string generatedCode = null;
                    instructionParsers[opCodeKey]?.Invoke(i, opCodes[i], out generatedCode);
                    if(generatedCode != null)
                        builder.Append(generatedCode);
                }
                else
                {
                    Console.WriteLine($"No parser found for {i.ToString("X2")} -> \"{opCodes[i]}\"!!!");
                }
            }

            #region Base File End
            builder.Append(
                "\t\t};\n" +
                "\t}\n" +
                "}\n");
            #endregion

            StreamWriter writer = File.CreateText("E:\\InstructionSet.cs");
            writer.Write(builder.ToString());
            writer.Close();
            writer.Dispose();

            isParsing = false;
        }
    }
}
